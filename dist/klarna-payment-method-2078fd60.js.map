{"version":3,"file":"klarna-payment-method-2078fd60.js","mappings":"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","sources":["webpack://checkout/./packages/hosted-widget-integration/src/EditButton.tsx","webpack://checkout/./packages/hosted-widget-integration/src/PaymentDescriptor.tsx","webpack://checkout/./packages/hosted-widget-integration/src/PaymentWidget.tsx","webpack://checkout/./packages/hosted-widget-integration/src/HostedWidgetPaymentComponent.tsx","webpack://checkout/./packages/instrument-utils/src/guards/isInstrumentCardCodeRequired/isInstrumentCardCodeRequired.ts","webpack://checkout/./packages/instrument-utils/src/guards/isInstrumentCardCodeRequiredSelector.ts","webpack://checkout/./packages/instrument-utils/src/guards/isInstrumentCardNumberRequiredSelector.ts","webpack://checkout/./packages/instrument-utils/src/guards/isInstrumentCardNumberRequired/isInstrumentCardNumberRequired.ts","webpack://checkout/./packages/instrument-utils/src/storedInstrument/InstrumentSelect/InstrumentSelect.tsx","webpack://checkout/./packages/instrument-utils/src/storedInstrument/CardInstrumentFieldset/CardInstrumentFieldset.tsx","webpack://checkout/./packages/instrument-utils/src/storedInstrument/mapFromInstrumentCardType/mapFromInstrumentCardType.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/missing-data-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/not-initialized-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/webpack/bootstrap","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/to-resolvable-module.ts","webpack://checkout/@bigcommerce/checkout-sdk/webpack/runtime/define property getters","webpack://checkout/@bigcommerce/checkout-sdk/webpack/runtime/hasOwnProperty shorthand","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/standard-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/set-prototype-of.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/invalid-argument-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/order-finalization-not-required-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-cancelled-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/request-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-invalid-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarnav2/klarna-supported-countries.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarna/klarna-payment-strategy.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-client-unavailable-error.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarna/klarna-script-loader.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarna/create-klarna-payment-strategy.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/common/http-request/content-type.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarnav2/klarnav2-payment-strategy.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/utility/src/is-experiment-enabled/is-experiment-enabled.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarnav2/klarnav2-script-loader.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/common/http-request/internal-api-headers.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/common/http-request/sdk-version-headers.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarnav2/klarnav2-token-updater.ts","webpack://checkout/@bigcommerce/checkout-sdk/./packages/klarna-integration/src/klarnav2/create-klarnav2-payment-strategy.ts","webpack://checkout/./packages/klarna-integration/src/klarna/KlarnaPaymentMethod.tsx","webpack://checkout/./packages/klarna-integration/src/klarnav2/KlarnaV2PaymentMethod.tsx"],"sourcesContent":["import classNames from 'classnames';\nimport React, { type ReactNode } from 'react';\n\nimport { preventDefault } from '@bigcommerce/checkout/dom-utils';\nimport { TranslatedString } from '@bigcommerce/checkout/locale';\n\ninterface EditButtonProps {\n    buttonId: string | undefined;\n    shouldShowEditButton: boolean | undefined;\n}\n\nexport const EditButton = ({ buttonId, shouldShowEditButton }: EditButtonProps): ReactNode => {\n    if (shouldShowEditButton) {\n        const translatedString = <TranslatedString id=\"remote.select_different_card_action\" />;\n\n        return (\n            <p>\n                <button\n                    className={classNames('stepHeader', 'widget-link-amazonpay')}\n                    id={buttonId}\n                    onClick={preventDefault()}\n                    type=\"button\"\n                >\n                    {translatedString}\n                </button>\n            </p>\n        );\n    }\n\n    return null;\n};\n","import React, { type ReactNode } from 'react';\n\ninterface PaymentDescriptorProps {\n    paymentDescriptor: string | undefined;\n    shouldShowDescriptor: boolean | undefined;\n}\n\nexport const PaymentDescriptor = ({\n    shouldShowDescriptor,\n    paymentDescriptor,\n}: PaymentDescriptorProps): ReactNode => {\n    if (shouldShowDescriptor && paymentDescriptor) {\n        return <div className=\"payment-descriptor\">{paymentDescriptor}</div>;\n    }\n\n    return null;\n};\n","import { type PaymentMethod } from '@bigcommerce/checkout-sdk';\nimport classNames from 'classnames';\nimport React, { type ReactElement } from 'react';\n\ninterface PaymentWidgetProps {\n    additionalContainerClassName: string | undefined;\n    containerId: string;\n    hideContentWhenSignedOut: boolean;\n    hideWidget: boolean;\n    isSignInRequired: boolean | undefined;\n    isSignedIn: boolean;\n    method: PaymentMethod;\n    renderCustomPaymentForm: (() => React.ReactNode) | undefined;\n    shouldRenderCustomInstrument: boolean;\n    shouldShowCreditCardFieldset: boolean;\n}\n\nexport const PaymentWidget = ({\n    additionalContainerClassName,\n    containerId,\n    hideContentWhenSignedOut,\n    hideWidget,\n    isSignInRequired,\n    isSignedIn,\n    method,\n    renderCustomPaymentForm,\n    shouldRenderCustomInstrument,\n    shouldShowCreditCardFieldset,\n}: PaymentWidgetProps): ReactElement => (\n    <div\n        className={classNames(\n            'widget',\n            `widget--${method.id}`,\n            'payment-widget',\n            shouldRenderCustomInstrument ? '' : additionalContainerClassName,\n        )}\n        id={containerId}\n        style={{\n            display:\n                (hideContentWhenSignedOut && isSignInRequired && !isSignedIn) ||\n                !shouldShowCreditCardFieldset ||\n                hideWidget\n                    ? 'none'\n                    : undefined,\n        }}\n        tabIndex={-1}\n    >\n        {shouldRenderCustomInstrument && renderCustomPaymentForm && renderCustomPaymentForm()}\n    </div>\n);\n","import {\n    type AccountInstrument,\n    type CardInstrument,\n    type CheckoutSelectors,\n    type CustomerInitializeOptions,\n    type CustomerRequestOptions,\n    type Instrument,\n    type PaymentInitializeOptions,\n    type PaymentInstrument,\n    type PaymentMethod,\n    type PaymentRequestOptions,\n} from '@bigcommerce/checkout-sdk';\nimport { find, noop } from 'lodash';\nimport React, {\n    type ReactElement,\n    type ReactNode,\n    useCallback,\n    useEffect,\n    useRef,\n    useState,\n} from 'react';\nimport { type ObjectSchema } from 'yup';\n\nimport {\n    AccountInstrumentFieldset,\n    assertIsCardInstrument,\n    CardInstrumentFieldset,\n    isBankAccountInstrument,\n    isCardInstrument,\n    StoreInstrumentFieldset,\n} from '@bigcommerce/checkout/instrument-utils';\nimport { type PaymentFormValues } from '@bigcommerce/checkout/payment-integration-api';\nimport { LoadingOverlay } from '@bigcommerce/checkout/ui';\n\nimport { EditButton } from './EditButton';\nimport { PaymentDescriptor } from './PaymentDescriptor';\nimport { PaymentWidget } from './PaymentWidget';\n\nexport interface PaymentContextProps {\n    disableSubmit(method: PaymentMethod, disabled?: boolean): void;\n    // NOTE: This prop allows certain payment methods to override the default\n    // form submission behaviour. It is not recommended to use it because\n    // generally speaking we want to avoid method-specific snowflake behaviours.\n    // Nevertheless, because of some product / UX decisions made in the past\n    // (i.e.: Amazon), we have to have this backdoor so we can preserve these\n    // snowflake behaviours. In the future, if we decide to change the UX, we\n    // can remove this prop.\n    setSubmit(method: PaymentMethod, fn: ((values: PaymentFormValues) => void) | null): void;\n    setFieldValue<TField extends keyof PaymentFormValues>(\n        field: TField,\n        value: PaymentFormValues[TField],\n    ): void;\n    setValidationSchema(\n        method: PaymentMethod,\n        schema: ObjectSchema<Partial<PaymentFormValues>> | null,\n    ): void;\n    hidePaymentSubmitButton(method: PaymentMethod, hidden?: boolean): void;\n}\n\nexport interface WithCheckoutHostedWidgetPaymentMethodProps {\n    instruments: PaymentInstrument[];\n    isInstrumentFeatureAvailable: boolean;\n    isLoadingInstruments: boolean;\n    isPaymentDataRequired: boolean;\n    isSignedIn: boolean;\n    isInstrumentCardCodeRequired(instrument: Instrument, method: PaymentMethod): boolean;\n    isInstrumentCardNumberRequired(instrument: Instrument, method: PaymentMethod): boolean;\n    loadInstruments(): Promise<CheckoutSelectors>;\n    signOut(options: CustomerRequestOptions): void;\n}\n\nexport interface HostedWidgetComponentProps extends WithCheckoutHostedWidgetPaymentMethodProps {\n    additionalContainerClassName?: string;\n    buttonId?: string;\n    containerId: string;\n    hideContentWhenSignedOut?: boolean;\n    hideVerificationFields?: boolean;\n    isAccountInstrument?: boolean;\n    hideWidget?: boolean;\n    isInitializing?: boolean;\n    isUsingMultiShipping?: boolean;\n    isSignInRequired?: boolean;\n    method: PaymentMethod;\n    paymentDescriptor?: string;\n    shouldHideInstrumentExpiryDate?: boolean;\n    shouldShow?: boolean;\n    shouldShowDescriptor?: boolean;\n    shouldShowEditButton?: boolean;\n    shouldRenderCustomInstrument?: boolean;\n    storedCardValidationSchema?: ObjectSchema;\n    renderCustomPaymentForm?(): React.ReactNode;\n    validateInstrument?(\n        shouldShowNumberField: boolean,\n        selectedInstrument?: CardInstrument,\n    ): React.ReactNode;\n    deinitializeCustomer?(options: CustomerRequestOptions): Promise<CheckoutSelectors>;\n    deinitializePayment(options: PaymentRequestOptions): Promise<CheckoutSelectors>;\n    initializeCustomer?(options: CustomerInitializeOptions): Promise<CheckoutSelectors>;\n    initializePayment(\n        options: PaymentInitializeOptions,\n        selectedInstrument?: CardInstrument,\n    ): Promise<CheckoutSelectors>;\n    onPaymentSelect?(): void;\n    onSignOut?(): void;\n    onSignOutError?(error: Error): void;\n    onUnhandledError?(error: Error): void;\n    signInCustomer?(): void;\n}\n\nconst HostedWidgetPaymentComponent = ({\n    instruments,\n    hideWidget = false,\n    isInitializing = false,\n    isAccountInstrument,\n    isInstrumentFeatureAvailable: isInstrumentFeatureAvailableProp,\n    isLoadingInstruments,\n    shouldHideInstrumentExpiryDate = false,\n    shouldShow = true,\n    hideVerificationFields,\n    method,\n    storedCardValidationSchema,\n    isPaymentDataRequired,\n    setValidationSchema,\n    loadInstruments,\n    onUnhandledError = noop,\n    deinitializeCustomer,\n    deinitializePayment,\n    setSubmit,\n    initializeCustomer,\n    initializePayment,\n    signInCustomer,\n    isSignedIn,\n    isSignInRequired,\n    isInstrumentCardNumberRequired,\n    validateInstrument,\n    containerId,\n    hideContentWhenSignedOut = false,\n    renderCustomPaymentForm,\n    additionalContainerClassName,\n    shouldRenderCustomInstrument = false,\n    paymentDescriptor,\n    shouldShowDescriptor,\n    shouldShowEditButton,\n    buttonId,\n    setFieldValue,\n}: HostedWidgetComponentProps & PaymentContextProps): ReactElement => {\n    const [isAddingNewCard, setIsAddingNewCard] = useState(false);\n    const [selectedInstrumentId, setSelectedInstrumentId] = useState<string | undefined>(undefined);\n    const instrumentsRef = useRef<PaymentInstrument[]>(instruments);\n\n    useEffect(() => {\n        instrumentsRef.current = instruments;\n    }, [instruments]);\n\n    const getDefaultInstrumentId = useCallback((): string | undefined => {\n        if (isAddingNewCard) {\n            return undefined;\n        }\n\n        const defaultInstrument =\n            instrumentsRef.current.find((instrument) => instrument.defaultInstrument) ||\n            instrumentsRef.current[0];\n\n        return defaultInstrument ? defaultInstrument.bigpayToken : undefined;\n    }, [isAddingNewCard]);\n\n    const getSelectedInstrument = useCallback((): PaymentInstrument | undefined => {\n        const currentSelectedId = selectedInstrumentId || getDefaultInstrumentId();\n\n        return find(instrumentsRef.current, { bigpayToken: currentSelectedId });\n    }, [selectedInstrumentId, getDefaultInstrumentId]);\n\n    const getValidationSchema = useCallback((): ObjectSchema | null => {\n        if (!isPaymentDataRequired) {\n            return null;\n        }\n\n        const currentSelectedInstrument = getSelectedInstrument();\n\n        if (isInstrumentFeatureAvailableProp && currentSelectedInstrument) {\n            return storedCardValidationSchema || null;\n        }\n\n        return null;\n    }, [\n        getSelectedInstrument,\n        isInstrumentFeatureAvailableProp,\n        isPaymentDataRequired,\n        storedCardValidationSchema,\n    ]);\n\n    const getSelectedBankAccountInstrument = useCallback(\n        (\n            addingNew: boolean,\n            currentSelectedInstrument: PaymentInstrument,\n        ): AccountInstrument | undefined => {\n            return !addingNew && isBankAccountInstrument(currentSelectedInstrument)\n                ? currentSelectedInstrument\n                : undefined;\n        },\n        [],\n    );\n\n    const handleDeleteInstrument = useCallback(\n        (id: string): void => {\n            if (instruments.length === 0) {\n                setIsAddingNewCard(true);\n                setSelectedInstrumentId(undefined);\n                setFieldValue('instrumentId', '');\n\n                return;\n            }\n\n            if (selectedInstrumentId === id) {\n                const nextId = getDefaultInstrumentId();\n\n                setSelectedInstrumentId(nextId);\n                setFieldValue('instrumentId', nextId);\n            }\n        },\n        [instruments, selectedInstrumentId, getDefaultInstrumentId],\n    );\n\n    const handleUseNewCard = useCallback(async () => {\n        setIsAddingNewCard(true);\n        setSelectedInstrumentId(undefined);\n\n        if (deinitializePayment) {\n            await deinitializePayment({\n                gatewayId: method.gateway,\n                methodId: method.id,\n            });\n        }\n\n        if (initializePayment) {\n            await initializePayment({\n                gatewayId: method.gateway,\n                methodId: method.id,\n            });\n        }\n    }, [method, deinitializePayment, initializePayment]);\n\n    const handleSelectInstrument = useCallback((id: string) => {\n        setIsAddingNewCard(false);\n        setSelectedInstrumentId(id);\n    }, []);\n\n    const getValidateInstrument = useCallback((): ReactNode | undefined => {\n        const currentSelectedId = selectedInstrumentId || getDefaultInstrumentId();\n        const currentSelectedInstrument = find(instruments, { bigpayToken: currentSelectedId });\n\n        if (currentSelectedInstrument) {\n            assertIsCardInstrument(currentSelectedInstrument);\n\n            const shouldShowNumberField = isInstrumentCardNumberRequired(\n                currentSelectedInstrument,\n                method,\n            );\n\n            if (hideVerificationFields) {\n                return undefined;\n            }\n\n            if (validateInstrument) {\n                return validateInstrument(shouldShowNumberField, currentSelectedInstrument);\n            }\n        }\n\n        return undefined;\n    }, [\n        selectedInstrumentId,\n        getDefaultInstrumentId,\n        instruments,\n        method,\n        hideVerificationFields,\n        validateInstrument,\n    ]);\n\n    const initializeMethod = async (): Promise<CheckoutSelectors | void> => {\n        const currentInstruments = instrumentsRef.current;\n\n        if (!isPaymentDataRequired) {\n            setSubmit(method, null);\n\n            return;\n        }\n\n        if (isSignInRequired && !isSignedIn) {\n            setSubmit(method, signInCustomer || null);\n\n            if (initializeCustomer) {\n                return initializeCustomer({ methodId: method.id });\n            }\n\n            return;\n        }\n\n        setSubmit(method, null);\n\n        let selectedCardInstrument: CardInstrument | undefined;\n\n        if (!isAddingNewCard) {\n            const currentSelectedInstrumentId = selectedInstrumentId || getDefaultInstrumentId();\n            const maybeInstrument =\n                currentInstruments.find(\n                    (instrument) => instrument.bigpayToken === currentSelectedInstrumentId,\n                ) || currentInstruments[0];\n\n            if (maybeInstrument && isCardInstrument(maybeInstrument)) {\n                selectedCardInstrument = maybeInstrument;\n            }\n        }\n\n        if (initializePayment) {\n            return initializePayment(\n                { gatewayId: method.gateway, methodId: method.id },\n                selectedCardInstrument,\n            );\n        }\n    };\n\n    // Below values are for lower level components\n    const effectiveSelectedInstrumentId = selectedInstrumentId || getDefaultInstrumentId();\n    const selectedInstrument = effectiveSelectedInstrumentId\n        ? instruments.find((i) => i.bigpayToken === effectiveSelectedInstrumentId) || instruments[0]\n        : instruments[0];\n    const cardInstruments: CardInstrument[] = instruments.filter(\n        (i): i is CardInstrument => !isBankAccountInstrument(i),\n    );\n    const accountInstruments: AccountInstrument[] = instruments.filter(\n        (i): i is AccountInstrument => isBankAccountInstrument(i),\n    );\n    const shouldShowInstrumentFieldset = isInstrumentFeatureAvailableProp && instruments.length > 0;\n    const shouldShowCreditCardFieldset = !shouldShowInstrumentFieldset || isAddingNewCard;\n    const isLoading = (isInitializing || isLoadingInstruments) && !hideWidget;\n    const selectedAccountInstrument = selectedInstrument\n        ? getSelectedBankAccountInstrument(isAddingNewCard, selectedInstrument)\n        : undefined;\n    const shouldShowAccountInstrument = instruments[0] && isBankAccountInstrument(instruments[0]);\n\n    useEffect(() => {\n        const init = async () => {\n            setValidationSchema(method, getValidationSchema());\n\n            try {\n                if (isInstrumentFeatureAvailableProp) {\n                    await loadInstruments?.();\n                }\n\n                await initializeMethod();\n            } catch (error: unknown) {\n                if (error instanceof Error) {\n                    onUnhandledError(error);\n                }\n            }\n        };\n\n        void init();\n\n        return () => {\n            const deInit = async () => {\n                setValidationSchema(method, null);\n                setSubmit(method, null);\n\n                try {\n                    if (deinitializePayment) {\n                        await deinitializePayment({\n                            gatewayId: method.gateway,\n                            methodId: method.id,\n                        });\n                    }\n\n                    if (deinitializeCustomer) {\n                        await deinitializeCustomer({ methodId: method.id });\n                    }\n                } catch (error: unknown) {\n                    if (error instanceof Error) {\n                        onUnhandledError(error);\n                    }\n                }\n            };\n\n            void deInit();\n        };\n    }, []);\n\n    const isInitialRenderRef = useRef(true);\n    const instrumentsLength = useRef(instruments.length);\n    const isPaymentDataRequiredRef = useRef(isPaymentDataRequired);\n    const selectedInstrumentIdRef = useRef(selectedInstrumentId);\n\n    useEffect(() => {\n        if (isInitialRenderRef.current) {\n            isInitialRenderRef.current = false;\n\n            return;\n        }\n\n        setValidationSchema(method, getValidationSchema());\n\n        const reInit = async () => {\n            try {\n                if (deinitializePayment) {\n                    await deinitializePayment({\n                        gatewayId: method.gateway,\n                        methodId: method.id,\n                    });\n                }\n\n                await initializeMethod();\n            } catch (error: unknown) {\n                if (error instanceof Error) {\n                    onUnhandledError(error);\n                }\n            }\n        };\n\n        if (\n            selectedInstrumentIdRef.current !== selectedInstrumentId ||\n            (Number(instrumentsLength.current) > 0 && instruments.length === 0) ||\n            isPaymentDataRequiredRef.current !== isPaymentDataRequired\n        ) {\n            selectedInstrumentIdRef.current = selectedInstrumentId;\n            instrumentsLength.current = instruments.length;\n            isPaymentDataRequiredRef.current = isPaymentDataRequired;\n\n            void reInit();\n        }\n    }, [selectedInstrumentId, instruments, isPaymentDataRequired]);\n\n    if (!shouldShow) {\n        return <div style={{ display: 'none' }} />;\n    }\n\n    return (\n        <LoadingOverlay hideContentWhenLoading isLoading={isLoading}>\n            <div className=\"paymentMethod--hosted\">\n                {shouldShowAccountInstrument && shouldShowInstrumentFieldset && (\n                    <AccountInstrumentFieldset\n                        instruments={accountInstruments}\n                        onSelectInstrument={handleSelectInstrument}\n                        onUseNewInstrument={handleUseNewCard}\n                        selectedInstrument={selectedAccountInstrument}\n                    />\n                )}\n                {!shouldShowAccountInstrument && shouldShowInstrumentFieldset && (\n                    <CardInstrumentFieldset\n                        instruments={cardInstruments}\n                        onDeleteInstrument={handleDeleteInstrument}\n                        onSelectInstrument={handleSelectInstrument}\n                        onUseNewInstrument={handleUseNewCard}\n                        selectedInstrumentId={effectiveSelectedInstrumentId}\n                        shouldHideExpiryDate={shouldHideInstrumentExpiryDate}\n                        validateInstrument={getValidateInstrument()}\n                    />\n                )}\n\n                <PaymentDescriptor\n                    paymentDescriptor={paymentDescriptor}\n                    shouldShowDescriptor={shouldShowDescriptor}\n                />\n\n                <PaymentWidget\n                    additionalContainerClassName={additionalContainerClassName}\n                    containerId={containerId}\n                    hideContentWhenSignedOut={hideContentWhenSignedOut}\n                    hideWidget={hideWidget}\n                    isSignInRequired={isSignInRequired}\n                    isSignedIn={isSignedIn}\n                    method={method}\n                    renderCustomPaymentForm={renderCustomPaymentForm}\n                    shouldRenderCustomInstrument={shouldRenderCustomInstrument}\n                    shouldShowCreditCardFieldset={shouldShowCreditCardFieldset}\n                />\n\n                {isInstrumentFeatureAvailableProp && (\n                    <StoreInstrumentFieldset\n                        instrumentId={effectiveSelectedInstrumentId}\n                        instruments={instruments}\n                        isAccountInstrument={Boolean(\n                            isAccountInstrument || shouldShowAccountInstrument,\n                        )}\n                    />\n                )}\n\n                <EditButton buttonId={buttonId} shouldShowEditButton={shouldShowEditButton} />\n            </div>\n        </LoadingOverlay>\n    );\n};\n\nexport default HostedWidgetPaymentComponent;\n","import {\n    type LineItemMap,\n    type PaymentInstrument,\n    type PaymentMethod,\n} from '@bigcommerce/checkout-sdk';\n\nexport const PROVIDERS_WITHOUT_CARD_CODE = ['bluesnapdirect'];\n\nexport interface IsInstrumentCardCodeRequiredState {\n    instrument: PaymentInstrument;\n    lineItems: LineItemMap;\n    paymentMethod: PaymentMethod;\n}\n\nexport default function isInstrumentCardCodeRequired({\n    instrument,\n    lineItems,\n    paymentMethod,\n}: IsInstrumentCardCodeRequiredState): boolean {\n    const {\n        config: { isVaultingCvvEnabled, cardCode },\n        initializationData,\n    } = paymentMethod;\n    const { isVaultingCardCodeValidationAvailable = true } = initializationData || {};\n\n    if (\n        PROVIDERS_WITHOUT_CARD_CODE.includes(instrument.provider) ||\n        !isVaultingCardCodeValidationAvailable\n    ) {\n        return false;\n    }\n\n    // If there's a digital item in the cart, always show CVV field\n    if (lineItems.digitalItems.length > 0 || lineItems.giftCertificates.length > 0) {\n        return true;\n    }\n\n    // If the shipping address is trusted, show CVV field based on the merchant's configuration\n    if (instrument.trustedShippingAddress) {\n        return !!isVaultingCvvEnabled;\n    }\n\n    // Otherwise, if the shipping address is untrusted, show CVV field if the\n    // merchant either requires it for regular card or stored card payments.\n    return !!(isVaultingCvvEnabled || cardCode);\n}\n","import {\n    type CheckoutSelectors,\n    type Instrument,\n    type PaymentMethod,\n} from '@bigcommerce/checkout-sdk';\nimport { createSelector } from 'reselect';\n\nimport isInstrumentCardCodeRequired from './isInstrumentCardCodeRequired/isInstrumentCardCodeRequired';\n\nconst isInstrumentCardCodeRequiredSelector = createSelector(\n    ({ data }: CheckoutSelectors) => {\n        const cart = data.getCart();\n\n        return cart && cart.lineItems;\n    },\n    (lineItems) => (instrument: Instrument, method: PaymentMethod) => {\n        if (!lineItems) {\n            return false;\n        }\n\n        return isInstrumentCardCodeRequired({\n            instrument,\n            lineItems,\n            paymentMethod: method,\n        });\n    },\n);\n\nexport default isInstrumentCardCodeRequiredSelector;\n","import {\n    type CheckoutSelectors,\n    type Instrument,\n    type PaymentMethod,\n} from '@bigcommerce/checkout-sdk';\nimport { createSelector } from 'reselect';\n\nimport isInstrumentCardNumberRequired from './isInstrumentCardNumberRequired/isInstrumentCardNumberRequired';\n\nconst isInstrumentCardNumberRequiredSelector = createSelector(\n    ({ data }: CheckoutSelectors) => {\n        const cart = data.getCart();\n\n        return cart && cart.lineItems;\n    },\n    (lineItems) => (instrument: Instrument, paymentMethod?: PaymentMethod) => {\n        if (!lineItems) {\n            return false;\n        }\n\n        return isInstrumentCardNumberRequired({\n            lineItems,\n            instrument,\n            paymentMethod,\n        });\n    },\n);\n\nexport default isInstrumentCardNumberRequiredSelector;\n","import { type Instrument, type LineItemMap, type PaymentMethod } from '@bigcommerce/checkout-sdk';\n\nexport interface IsInstrumentCardNumberRequiredState {\n    lineItems: LineItemMap;\n    instrument: Instrument;\n    paymentMethod?: PaymentMethod;\n}\n\nexport default function isInstrumentCardNumberRequired({\n    lineItems,\n    instrument,\n    paymentMethod,\n}: IsInstrumentCardNumberRequiredState): boolean {\n    const { isVaultingCardNumberValidationAvailable = true } =\n        paymentMethod?.initializationData || {};\n\n    if (lineItems.physicalItems.length === 0 || !isVaultingCardNumberValidationAvailable) {\n        return false;\n    }\n\n    return !instrument.trustedShippingAddress;\n}\n","import { type CardInstrument } from '@bigcommerce/checkout-sdk';\nimport { expirationDate } from 'card-validator';\nimport classNames from 'classnames';\nimport creditCardType from 'credit-card-type';\nimport { type FieldProps } from 'formik';\nimport { find, noop } from 'lodash';\nimport React, { type FunctionComponent, useCallback, useEffect, useRef } from 'react';\n\nimport { TranslatedString } from '@bigcommerce/checkout/locale';\nimport { CreditCardIcon, DropdownTrigger } from '@bigcommerce/checkout/ui';\n\nimport { mapFromInstrumentCardType } from '../mapFromInstrumentCardType';\n\nexport interface InstrumentSelectProps extends FieldProps<string> {\n    instruments: CardInstrument[];\n    selectedInstrumentId?: string;\n    shouldHideExpiryDate?: boolean;\n    onSelectInstrument(id: string): void;\n    onUseNewInstrument(): void;\n}\n\nexport interface InstrumentSelectValues {\n    instrumentId: string;\n}\n\ninterface InstrumentMenuItemProps {\n    className?: string;\n    instrument: CardInstrument;\n    testId?: string;\n    shouldHideExpiryDate?: boolean;\n    onClick?(): void;\n}\n\nconst InstrumentMenuItem: FunctionComponent<InstrumentMenuItemProps> = ({\n    className,\n    instrument,\n    testId,\n    shouldHideExpiryDate = false,\n    onClick,\n}) => {\n    const cardType = mapFromInstrumentCardType(instrument.brand);\n    const cardInfo = creditCardType.getTypeInfo(cardType);\n    const isExpired = !expirationDate({\n        month: instrument.expiryMonth,\n        year: instrument.expiryYear,\n    }).isValid;\n\n    return (\n        <button className={className} data-test={testId} onClick={onClick} type=\"button\">\n            <div\n                className={classNames('instrumentSelect-details', {\n                    'instrumentSelect-details--expired': isExpired,\n                })}\n            >\n                <CreditCardIcon cardType={cardType} />\n\n                <div className=\"instrumentSelect-card\" data-test={`${testId ?? ''}-last4`}>\n                    {cardInfo ? (\n                        <TranslatedString\n                            data={{\n                                cardTitle: cardInfo.niceType ?? '',\n                                endingIn: instrument.last4,\n                            }}\n                            id=\"payment.instrument_ending_in_text\"\n                        />\n                    ) : (\n                        <TranslatedString\n                            data={{ endingIn: instrument.last4 }}\n                            id=\"payment.instrument_default_ending_in_text\"\n                        />\n                    )}\n                </div>\n\n                {!shouldHideExpiryDate && (\n                    <div\n                        className={classNames('instrumentSelect-expiry', {\n                            'instrumentSelect-expiry--expired': isExpired,\n                        })}\n                        data-test={`${testId || ''}-expiry`}\n                    >\n                        {isExpired ? (\n                            <TranslatedString\n                                data={{\n                                    expiryDate: `${instrument.expiryMonth}/${instrument.expiryYear}`,\n                                }}\n                                id=\"payment.instrument_expired_text\"\n                            />\n                        ) : (\n                            <TranslatedString\n                                data={{\n                                    expiryDate: `${instrument.expiryMonth}/${instrument.expiryYear}`,\n                                }}\n                                id=\"payment.instrument_expires_text\"\n                            />\n                        )}\n                    </div>\n                )}\n            </div>\n        </button>\n    );\n};\n\ninterface InstrumentOptionProps {\n    instrument: CardInstrument;\n    testId?: string;\n    shouldHideExpiryDate?: boolean;\n    onClick?(token: string): void;\n}\n\nconst InstrumentOption: FunctionComponent<InstrumentOptionProps> = ({\n    instrument,\n    shouldHideExpiryDate = false,\n    onClick = noop,\n}) => {\n    const handleClick = useCallback(() => {\n        onClick(instrument.bigpayToken);\n    }, [onClick, instrument]);\n\n    return (\n        <InstrumentMenuItem\n            instrument={instrument}\n            onClick={handleClick}\n            shouldHideExpiryDate={shouldHideExpiryDate}\n            testId=\"instrument-select-option\"\n        />\n    );\n};\n\ninterface InstrumentUseNewButtonProps {\n    className?: string;\n    testId?: string;\n    onClick?(): void;\n}\n\nconst InstrumentUseNewButton: FunctionComponent<InstrumentUseNewButtonProps> = ({\n    className,\n    testId,\n    onClick = noop,\n}) => (\n    <button className={className} data-test={testId} onClick={onClick} type=\"button\">\n        <div className=\"instrumentSelect-details instrumentSelect-details--addNew\">\n            <CreditCardIcon />\n\n            <div className=\"instrumentSelect-card\">\n                <TranslatedString id=\"payment.instrument_add_card_action\" />\n            </div>\n        </div>\n    </button>\n);\n\ninterface InstrumentMenuProps {\n    instruments: CardInstrument[];\n    selectedInstrumentId?: string;\n    shouldHideExpiryDate?: boolean;\n    onSelectInstrument(id: string): void;\n    onUseNewInstrument(): void;\n}\n\nconst InstrumentMenu: FunctionComponent<InstrumentMenuProps> = ({\n    instruments,\n    selectedInstrumentId,\n    shouldHideExpiryDate = false,\n    onSelectInstrument,\n    onUseNewInstrument,\n}) => {\n    return (\n        <ul\n            className=\"instrumentSelect-dropdownMenu instrumentSelect-dropdownMenuNext dropdown-menu\"\n            data-test=\"instrument-select-menu\"\n        >\n            {instruments.map((instrument) => (\n                <li\n                    className={classNames('instrumentSelect-option dropdown-menu-item', {\n                        'instrumentSelect-option--selected':\n                            instrument.bigpayToken === selectedInstrumentId,\n                    })}\n                    key={instrument.bigpayToken}\n                >\n                    <InstrumentOption\n                        instrument={instrument}\n                        onClick={onSelectInstrument}\n                        shouldHideExpiryDate={shouldHideExpiryDate}\n                        testId=\"instrument-select-option\"\n                    />\n                </li>\n            ))}\n\n            <li className=\"instrumentSelect-option instrumentSelect-option--addNew dropdown-menu-item\">\n                <InstrumentUseNewButton\n                    onClick={onUseNewInstrument}\n                    testId=\"instrument-select-option-use-new\"\n                />\n            </li>\n        </ul>\n    );\n};\n\ninterface InstrumentSelectButtonProps {\n    instrument?: CardInstrument;\n    shouldHideExpiryDate?: boolean;\n    testId?: string;\n    onClick?(): void;\n}\n\nconst InstrumentSelectButton: FunctionComponent<InstrumentSelectButtonProps> = ({\n    instrument,\n    shouldHideExpiryDate = false,\n    testId,\n    onClick,\n}) => {\n    if (!instrument) {\n        return (\n            <InstrumentUseNewButton\n                className=\"instrumentSelect-button optimizedCheckout-form-select dropdown-button form-input\"\n                testId={testId}\n            />\n        );\n    }\n\n    return (\n        <InstrumentMenuItem\n            className=\"instrumentSelect-button optimizedCheckout-form-select dropdown-button form-input\"\n            instrument={instrument}\n            onClick={onClick}\n            shouldHideExpiryDate={shouldHideExpiryDate}\n            testId={testId}\n        />\n    );\n};\n\nconst InstrumentSelect: FunctionComponent<InstrumentSelectProps> = ({\n    field,\n    form,\n    instruments,\n    onSelectInstrument,\n    onUseNewInstrument,\n    selectedInstrumentId,\n    shouldHideExpiryDate = false,\n}) => {\n    const prevSelectedInstrumentIdRef = useRef(selectedInstrumentId);\n\n    const updateFieldValue = useCallback(\n        (instrumentId = '') => {\n            void form.setFieldValue(field.name, instrumentId);\n        },\n        [form, field.name],\n    );\n\n    useEffect(() => {\n        // FIXME: Used setTimeout here because setFieldValue call doesnot set value if called before formik is properly mounted.\n        //        This ensures that update Field value is called after formik has mounted.\n        // See GitHub issue: https://github.com/jaredpalmer/formik/issues/930\n        setTimeout(() => updateFieldValue(selectedInstrumentId));\n\n        return () => {\n            if (field.value === '' && selectedInstrumentId !== undefined) {\n                updateFieldValue();\n            }\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    useEffect(() => {\n        if (prevSelectedInstrumentIdRef.current !== selectedInstrumentId) {\n            // FIXME: Used setTimeout here because setFieldValue call doesnot set value if called before formik is properly mounted.\n            //        This ensures that update Field value is called after formik has mounted.\n            // See GitHub issue: https://github.com/jaredpalmer/formik/issues/930\n            setTimeout(() => updateFieldValue(selectedInstrumentId));\n        }\n\n        prevSelectedInstrumentIdRef.current = selectedInstrumentId;\n    }, [selectedInstrumentId, updateFieldValue]);\n\n    const selectedInstrument = find(instruments, { bigpayToken: selectedInstrumentId });\n\n    return (\n        <div className=\"instrumentSelect\">\n            <DropdownTrigger\n                dropdown={\n                    <InstrumentMenu\n                        instruments={instruments}\n                        onSelectInstrument={onSelectInstrument}\n                        onUseNewInstrument={onUseNewInstrument}\n                        selectedInstrumentId={selectedInstrumentId}\n                        shouldHideExpiryDate={shouldHideExpiryDate}\n                    />\n                }\n            >\n                <InstrumentSelectButton\n                    instrument={selectedInstrument}\n                    shouldHideExpiryDate={shouldHideExpiryDate}\n                    testId=\"instrument-select\"\n                />\n\n                <input type=\"hidden\" {...field} />\n            </DropdownTrigger>\n        </div>\n    );\n};\n\nexport default InstrumentSelect;\n","import { type CardInstrument } from '@bigcommerce/checkout-sdk';\nimport { type FieldProps } from 'formik';\nimport React, { type FunctionComponent, memo, useCallback } from 'react';\n\nimport { TranslatedString } from '@bigcommerce/checkout/locale';\nimport {\n    BasicFormField,\n    Fieldset,\n    Legend,\n    ModalTrigger,\n    type ModalTriggerModalProps,\n} from '@bigcommerce/checkout/ui';\n\nimport { InstrumentSelect } from '../InstrumentSelect';\nimport { ManageInstrumentsModal } from '../ManageInstrumentsModal';\n\nexport interface CardInstrumentFieldsetProps {\n    instruments: CardInstrument[];\n    selectedInstrumentId?: string;\n    shouldHideExpiryDate?: boolean;\n    validateInstrument?: React.ReactNode;\n    onDeleteInstrument?(instrumentId: string): void;\n    onSelectInstrument(id: string): void;\n    onUseNewInstrument(): void;\n}\n\nconst CardInstrumentFieldset: FunctionComponent<CardInstrumentFieldsetProps> = ({\n    instruments,\n    onDeleteInstrument,\n    onSelectInstrument,\n    onUseNewInstrument,\n    selectedInstrumentId,\n    shouldHideExpiryDate = false,\n    validateInstrument = null,\n}) => {\n    const renderInput = useCallback(\n        (field: FieldProps<string>) => (\n            <InstrumentSelect\n                {...field}\n                instruments={instruments}\n                onSelectInstrument={onSelectInstrument}\n                onUseNewInstrument={onUseNewInstrument}\n                selectedInstrumentId={selectedInstrumentId}\n                shouldHideExpiryDate={shouldHideExpiryDate}\n            />\n        ),\n        [\n            instruments,\n            onSelectInstrument,\n            onUseNewInstrument,\n            selectedInstrumentId,\n            shouldHideExpiryDate,\n        ],\n    );\n\n    const renderModal = useCallback(\n        (props: ModalTriggerModalProps) => (\n            <ManageInstrumentsModal\n                instruments={instruments}\n                onDeleteInstrument={onDeleteInstrument}\n                {...props}\n            />\n        ),\n        [instruments, onDeleteInstrument],\n    );\n\n    return (\n        <Fieldset\n            additionalClassName=\"instrumentFieldset\"\n            legend={\n                <Legend hidden>\n                    <TranslatedString id=\"payment.instrument_text\" />\n                </Legend>\n            }\n        >\n            <ModalTrigger modal={renderModal}>\n                {({ onClick }) => (\n                    <button className=\"instrumentModal-trigger\" onClick={onClick} type=\"button\">\n                        <TranslatedString id=\"payment.instrument_manage_button\" />\n                    </button>\n                )}\n            </ModalTrigger>\n\n            <BasicFormField name=\"instrumentId\" render={renderInput} />\n\n            <div style={{ display: selectedInstrumentId ? undefined : 'none' }}>\n                {validateInstrument}\n            </div>\n        </Fieldset>\n    );\n};\n\nexport default memo(CardInstrumentFieldset);\n","export default function mapFromInstrumentCardType(type: string): string {\n    switch (type) {\n        case 'amex':\n        case 'american_express':\n            return 'american-express';\n\n        case 'diners':\n        case 'diners_club':\n            return 'diners-club';\n\n        default:\n            return type;\n    }\n}\n","import StandardError from './standard-error';\n\nexport enum MissingDataErrorType {\n    MissingBillingAddress,\n    MissingCart,\n    MissingCheckout,\n    MissingConsignments,\n    MissingCustomer,\n    MissingCheckoutConfig,\n    MissingOrder,\n    MissingOrderConfig,\n    MissingOrderId,\n    MissingPayment,\n    MissingPaymentId,\n    MissingPaymentInstrument,\n    MissingPaymentMethod,\n    MissingPaymentRedirectUrl,\n    MissingPaymentStatus,\n    MissingPaymentToken,\n    MissingShippingAddress,\n}\n\n/**\n * Throw this error when data that is expected to exist is missing. Usually it\n * is due to the fact that certain data has not been retrieved from or saved to\n * the server yet. And such data is required to perform certain actions.\n */\nexport default class MissingDataError extends StandardError {\n    constructor(public subtype: MissingDataErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'MissingDataError';\n        this.type = 'missing_data';\n    }\n}\n\nfunction getErrorMessage(type: MissingDataErrorType): string {\n    switch (type) {\n        case MissingDataErrorType.MissingBillingAddress:\n            return 'Unable to proceed because billing address data is unavailable.';\n\n        case MissingDataErrorType.MissingCart:\n            return 'Unable to proceed because cart data is unavailable.';\n\n        case MissingDataErrorType.MissingConsignments:\n            return 'Unable to proceed because consignments data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckout:\n            return 'Unable to proceed because checkout data is unavailable.';\n\n        case MissingDataErrorType.MissingCustomer:\n            return 'Unable to proceed because customer data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckoutConfig:\n        case MissingDataErrorType.MissingOrderConfig:\n            return 'Unable to proceed because configuration data is unavailable.';\n\n        case MissingDataErrorType.MissingOrder:\n            return 'Unable to proceed because order data is unavailable.';\n\n        case MissingDataErrorType.MissingOrderId:\n            return 'Unable to proceed because order ID is unavailable or not generated yet.';\n\n        case MissingDataErrorType.MissingPayment:\n            return 'Unable to proceed because payment data is unavailable.';\n\n        case MissingDataErrorType.MissingPaymentToken:\n            return 'Unable to proceed because the token required to submit a payment is missing.';\n\n        case MissingDataErrorType.MissingPaymentMethod:\n            return 'Unable to proceed because payment method data is unavailable or not properly configured.';\n\n        case MissingDataErrorType.MissingShippingAddress:\n            return 'Unable to proceed because shipping address data is unavailable.';\n\n        default:\n            return 'Unable to proceed because the required data is unavailable.';\n    }\n}\n","import StandardError from './standard-error';\n\nexport enum NotInitializedErrorType {\n    CheckoutButtonNotInitialized,\n    CustomerNotInitialized,\n    PaymentNotInitialized,\n    ShippingNotInitialized,\n    SpamProtectionNotInitialized,\n}\n\n/**\n * Throw this error if a method requires a certain initialization call to be\n * made first. Some objects can be constructed but they cannot be used until a\n * separate initialization call is made.\n */\nexport default class NotInitializedError extends StandardError {\n    constructor(public subtype: NotInitializedErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'NotInitializedError';\n        this.type = 'not_initialized';\n    }\n}\n\nfunction getErrorMessage(type: NotInitializedErrorType): string {\n    switch (type) {\n        case NotInitializedErrorType.CustomerNotInitialized:\n            return 'Unable to proceed because the customer step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.PaymentNotInitialized:\n            return 'Unable to proceed because the payment step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.ShippingNotInitialized:\n            return 'Unable to proceed because the shipping step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.SpamProtectionNotInitialized:\n            return 'Unable to proceed because the checkout spam protection has not been initialized.';\n\n        default:\n            return 'Unable to proceed because the required component has not been initialized.';\n    }\n}\n","// The require scope\nvar __webpack_require__ = {};\n\n","import ResolvableModule from './resolvable-module';\n\nexport default function toResolvableModule<TModule, TIdentifier>(\n    module: TModule,\n    resolveIds: TIdentifier[],\n): ResolvableModule<TModule, TIdentifier> {\n    return Object.assign(module, { resolveIds });\n}\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import CustomError from './custom-error';\nimport setPrototypeOf from './set-prototype-of';\n\n/**\n * This error type should not be constructed directly. It is a base class for\n * all custom errors thrown in this library.\n */\nexport default abstract class StandardError extends Error implements CustomError {\n    name = 'StandardError';\n    type = 'standard';\n\n    constructor(message?: string) {\n        super(message || 'An unexpected error has occurred.');\n\n        setPrototypeOf(this, new.target.prototype);\n\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, new.target);\n        } else {\n            this.stack = new Error(this.message).stack;\n        }\n    }\n}\n","export default function setPrototypeOf(object: any, prototype: object) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(object, prototype);\n    } else {\n        object.__proto__ = prototype;\n    }\n\n    return object;\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a method is unable to proceed because the\n * caller has not provided all the arguments according to their requirements,\n * i.e.: if an argument is missing or it is not the expected data type.\n */\nexport default class InvalidArgumentError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Invalid arguments have been provided.');\n\n        this.name = 'InvalidArgumentError';\n        this.type = 'invalid_argument';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * Throw this error if we are trying to make an order finalization request for a\n * payment method that does not require such procedure.\n */\nexport default class OrderFinalizationNotRequiredError extends StandardError {\n    constructor() {\n        super('The current order does not need to be finalized at this stage.');\n\n        this.name = 'OrderFinalizationNotRequiredError';\n        this.type = 'order_finalization_not_required';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the payment flow is cancelled. It could be\n * due to a deliberate user interaction, i.e.: the user clicks on a cancel\n * button which dismisses the payment modal.\n */\nexport default class PaymentMethodCancelledError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Payment process was cancelled.');\n\n        this.name = 'PaymentMethodCancelledError';\n        this.type = 'payment_cancelled';\n    }\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport StandardError from './standard-error';\n\nconst DEFAULT_RESPONSE = {\n    body: {},\n    headers: {},\n    status: 0,\n};\n\n/**\n * Throw this error if we are unable to make a request to the server. It wraps\n * any server response into a JS error object.\n */\nexport default class RequestError<TBody = any> extends StandardError {\n    body: TBody | {};\n    headers: { [key: string]: any };\n    errors: Array<{ code: string; message?: string }>;\n    status: number;\n\n    constructor(\n        response?: Response<TBody | {}>,\n        {\n            message,\n            errors,\n        }: {\n            message?: string;\n            errors?: Array<{ code: string; message?: string }>;\n        } = {},\n    ) {\n        const { body, headers, status } = response || DEFAULT_RESPONSE;\n\n        super(message || 'An unexpected error has occurred.');\n\n        this.name = 'RequestError';\n        this.type = 'request';\n        this.body = body;\n        this.headers = headers;\n        this.status = status;\n        this.errors = errors || [];\n    }\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport RequestError from './request-error';\n\n/**\n * Throw this error if we are unable to successfully submit a server request\n * using a payment method because the method has invalid configuration or is in\n * an invalid state.\n */\nexport default class PaymentMethodInvalidError<T = any> extends RequestError<T> {\n    constructor(response?: Response<T>) {\n        super(response, {\n            message: 'There is a problem processing your payment. Please try again later.',\n        });\n\n        this.name = 'PaymentMethodInvalidError';\n        this.type = 'payment_method_invalid';\n    }\n}\n","export const supportedCountries = [\n    'AT',\n    'BE',\n    'CA',\n    'CH',\n    'CZ',\n    'DE',\n    'DK',\n    'ES',\n    'FI',\n    'FR',\n    'GB',\n    'GR',\n    'IE',\n    'IT',\n    'NL',\n    'NO',\n    'NZ',\n    'PL',\n    'PT',\n    'SE',\n];\nexport const supportedCountriesRequiringStates = ['AU'];\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport { includes } from 'lodash';\n\nimport {\n    Address,\n    BillingAddress,\n    InvalidArgumentError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    PaymentInitializeOptions,\n    PaymentIntegrationService,\n    PaymentMethodCancelledError,\n    PaymentMethodInvalidError,\n    PaymentRequestOptions,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport {\n    supportedCountries,\n    supportedCountriesRequiringStates,\n} from '../klarnav2/klarna-supported-countries';\n\nimport KlarnaCredit, {\n    KlarnaAddress,\n    KlarnaAuthorizationResponse,\n    KlarnaLoadResponse,\n    KlarnaUpdateSessionParams,\n} from './klarna-credit';\nimport { WithKlarnaPaymentInitializeOptions } from './klarna-payment-initialize-options';\nimport KlarnaScriptLoader from './klarna-script-loader';\n\nexport default class KlarnaPaymentStrategy {\n    private klarnaCredit?: KlarnaCredit;\n    private unsubscribe?: () => void;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private klarnaScriptLoader: KlarnaScriptLoader,\n    ) {}\n\n    async initialize(\n        options: PaymentInitializeOptions & WithKlarnaPaymentInitializeOptions,\n    ): Promise<void> {\n        this.klarnaCredit = await this.klarnaScriptLoader.load();\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.unsubscribe = this.paymentIntegrationService.subscribe(\n            (state) => {\n                if (\n                    state.isPaymentMethodInitialized({\n                        methodId: options.methodId,\n                        gatewayId: options.gatewayId,\n                    })\n                ) {\n                    void this.loadWidget(options);\n                }\n            },\n            (state) => {\n                const checkout = state.getCheckout();\n\n                return checkout && checkout.outstandingBalance;\n            },\n            (state) => {\n                const checkout = state.getCheckout();\n\n                return checkout && checkout.coupons;\n            },\n        );\n\n        await this.loadWidget(options);\n    }\n\n    deinitialize(): Promise<void> {\n        if (this.unsubscribe) {\n            this.unsubscribe();\n        }\n\n        return Promise.resolve();\n    }\n\n    async execute(payload: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        if (!payload.payment) {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"payload.payment\" argument is not provided.',\n            );\n        }\n\n        const {\n            payment: { paymentData, ...paymentPayload },\n        } = payload;\n\n        const { authorization_token: authorizationToken } = await this.authorize();\n\n        await this.paymentIntegrationService.initializePayment(paymentPayload.methodId, {\n            authorizationToken,\n        });\n\n        await this.paymentIntegrationService.submitOrder(\n            {\n                ...payload,\n                payment: paymentPayload,\n                useStoreCredit: payload.useStoreCredit,\n            },\n            options,\n        );\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    private async loadWidget(\n        options: PaymentInitializeOptions & WithKlarnaPaymentInitializeOptions,\n    ): Promise<KlarnaLoadResponse> {\n        if (!options.klarna) {\n            throw new InvalidArgumentError(\n                'Unable to load widget because \"options.klarna\" argument is not provided.',\n            );\n        }\n\n        const {\n            methodId,\n            klarna: { container, onLoad },\n        } = options;\n\n        await this.paymentIntegrationService.loadPaymentMethod(methodId);\n\n        return new Promise<KlarnaLoadResponse>((resolve) => {\n            const paymentMethod = this.paymentIntegrationService\n                .getState()\n                .getPaymentMethod(methodId);\n\n            if (!paymentMethod) {\n                throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n            }\n\n            if (!this.klarnaCredit || !paymentMethod.clientToken) {\n                throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n            }\n\n            this.klarnaCredit.init({ client_token: paymentMethod.clientToken });\n\n            this.klarnaCredit.load({ container }, (response) => {\n                if (onLoad) {\n                    onLoad(response);\n                }\n\n                resolve(response);\n            });\n        });\n    }\n\n    private getUpdateSessionData(\n        billingAddress: BillingAddress,\n        shippingAddress?: Address,\n    ): KlarnaUpdateSessionParams {\n        if (\n            !includes(\n                [...supportedCountries, ...supportedCountriesRequiringStates],\n                billingAddress.countryCode,\n            )\n        ) {\n            return {};\n        }\n\n        const data: KlarnaUpdateSessionParams = {\n            billing_address: this.mapToKlarnaAddress(billingAddress, billingAddress.email),\n        };\n\n        if (shippingAddress) {\n            data.shipping_address = this.mapToKlarnaAddress(shippingAddress, billingAddress.email);\n        }\n\n        return data;\n    }\n\n    private needsStateCode(countryCode: string) {\n        return includes(supportedCountriesRequiringStates, countryCode);\n    }\n\n    private mapToKlarnaAddress(address: Address, email?: string): KlarnaAddress {\n        const klarnaAddress: KlarnaAddress = {\n            street_address: address.address1,\n            city: address.city,\n            country: address.countryCode,\n            given_name: address.firstName,\n            family_name: address.lastName,\n            postal_code: address.postalCode,\n            region: this.needsStateCode(address.countryCode)\n                ? address.stateOrProvinceCode\n                : address.stateOrProvince,\n            email,\n        };\n\n        if (address.address2) {\n            klarnaAddress.street_address2 = address.address2;\n        }\n\n        if (address.phone) {\n            klarnaAddress.phone = address.phone;\n        }\n\n        return klarnaAddress;\n    }\n\n    private authorize(): Promise<KlarnaAuthorizationResponse> {\n        return new Promise((resolve, reject) => {\n            const state = this.paymentIntegrationService.getState();\n            const billingAddress = state.getBillingAddress();\n            const shippingAddress = state.getShippingAddress();\n\n            if (!billingAddress) {\n                throw new MissingDataError(MissingDataErrorType.MissingBillingAddress);\n            }\n\n            if (!this.klarnaCredit) {\n                throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n            }\n\n            const updateSessionData = this.getUpdateSessionData(billingAddress, shippingAddress);\n\n            this.klarnaCredit.authorize(updateSessionData, (res) => {\n                if (res.approved) {\n                    return resolve(res);\n                }\n\n                if (res.show_form) {\n                    return reject(new PaymentMethodCancelledError());\n                }\n\n                reject(new PaymentMethodInvalidError());\n            });\n        });\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the client library of a payment method fails\n * to load, or for some reason, it is inaccessible.\n */\nexport default class PaymentMethodClientUnavailableError extends StandardError {\n    constructor(message?: string) {\n        super(\n            message ||\n                'Unable to proceed because the client library of a payment method is not loaded or ready to be used.',\n        );\n\n        this.name = 'PaymentMethodClientUnavailableError';\n        this.type = 'payment_method_client_unavailable';\n    }\n}\n","import { ScriptLoader } from '@bigcommerce/script-loader';\n\nimport { PaymentMethodClientUnavailableError } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport KlarnaCredit from './klarna-credit';\nimport KlarnaWindow from './klarna-window';\n\nconst SDK_URL = '//credit.klarnacdn.net/lib/v1/api.js';\n\nexport default class KlarnaScriptLoader {\n    constructor(private scriptLoader: ScriptLoader, private klarnaWindow: KlarnaWindow = window) {}\n\n    async load(): Promise<KlarnaCredit> {\n        if (!this.klarnaWindow.Klarna?.Credit) {\n            await this.scriptLoader.loadScript(SDK_URL);\n        }\n\n        if (!this.klarnaWindow.Klarna?.Credit) {\n            throw new PaymentMethodClientUnavailableError();\n        }\n\n        return this.klarnaWindow.Klarna.Credit;\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport KlarnaPaymentStrategy from './klarna-payment-strategy';\nimport KlarnaScriptLoader from './klarna-script-loader';\n\nconst createKlarnaPaymentStrategy: PaymentStrategyFactory<KlarnaPaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new KlarnaPaymentStrategy(\n        paymentIntegrationService,\n        new KlarnaScriptLoader(getScriptLoader()),\n    );\n};\n\nexport default toResolvableModule(createKlarnaPaymentStrategy, [{ id: 'klarna' }]);\n","enum ContentType {\n    Json = 'application/json',\n    JsonV1 = 'application/vnd.bc.v1+json',\n}\n\nexport default ContentType;\n","import { includes } from 'lodash';\n\nimport {\n    Address,\n    BillingAddress,\n    InvalidArgumentError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    PaymentInitializeOptions,\n    PaymentIntegrationService,\n    PaymentMethodCancelledError,\n    PaymentMethodInvalidError,\n    PaymentRequestOptions,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport { isExperimentEnabled } from '@bigcommerce/checkout-sdk/utility';\n\nimport KlarnaPayments, {\n    KlarnaAddress,\n    KlarnaAuthorizationResponse,\n    KlarnaInitializationData,\n    KlarnaLoadResponse,\n    KlarnaUpdateSessionParams,\n} from './klarna-payments';\nimport {\n    supportedCountries,\n    supportedCountriesRequiringStates,\n} from './klarna-supported-countries';\nimport { WithKlarnaV2PaymentInitializeOptions } from './klarnav2-payment-initialize-options';\nimport KlarnaV2ScriptLoader from './klarnav2-script-loader';\nimport KlarnaV2TokenUpdater from './klarnav2-token-updater';\n\nexport default class KlarnaV2PaymentStrategy {\n    private klarnaPayments?: KlarnaPayments;\n    private unsubscribe?: () => void;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private klarnav2ScriptLoader: KlarnaV2ScriptLoader,\n        private klarnav2TokenUpdater: KlarnaV2TokenUpdater,\n    ) {}\n\n    async initialize(\n        options: PaymentInitializeOptions & WithKlarnaV2PaymentInitializeOptions,\n    ): Promise<void> {\n        this.klarnaPayments = await this.klarnav2ScriptLoader.load();\n\n        this.unsubscribe = this.paymentIntegrationService.subscribe(\n            (state) => {\n                if (\n                    state.isPaymentMethodInitialized({\n                        methodId: options.methodId,\n                        gatewayId: options.gatewayId,\n                    })\n                ) {\n                    void this.loadPaymentsWidget(options);\n                }\n            },\n            (state) => {\n                const checkout = state.getCheckout();\n\n                return checkout && checkout.outstandingBalance;\n            },\n            (state) => {\n                const checkout = state.getCheckout();\n\n                return checkout && checkout.coupons;\n            },\n        );\n\n        await this.loadPaymentsWidget(options);\n    }\n\n    deinitialize(): Promise<void> {\n        if (this.unsubscribe) {\n            this.unsubscribe();\n        }\n\n        return Promise.resolve();\n    }\n\n    async execute(payload: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        if (!payload.payment) {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"payload.payment\" argument is not provided.',\n            );\n        }\n\n        const {\n            payment: { ...paymentPayload },\n        } = payload;\n        const { gatewayId, methodId } = paymentPayload;\n\n        if (!gatewayId) {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"payload.payment.gatewayId\" argument is not provided.',\n            );\n        }\n\n        const state = this.paymentIntegrationService.getState();\n        const { id: cartId } = state.getCartOrThrow();\n        const { clientToken, initializationData } =\n            state.getPaymentMethodOrThrow<KlarnaInitializationData>(methodId);\n        const { klarnaMultipleRadioButton } = initializationData || {};\n\n        await this.klarnav2TokenUpdater.klarnaOrderInitialization(cartId, clientToken);\n\n        const paymentMethodategory = this.isKlarnaMultipleRadioButtonEnabled(\n            klarnaMultipleRadioButton,\n            gatewayId,\n            methodId,\n        );\n        const { authorization_token: authorizationToken } = await this.authorizeOrThrow(\n            paymentMethodategory,\n            methodId,\n        );\n\n        await this.paymentIntegrationService.initializePayment(gatewayId, {\n            authorizationToken,\n        });\n\n        await this.paymentIntegrationService.submitOrder(\n            {\n                ...payload,\n                payment: paymentPayload,\n                useStoreCredit: payload.useStoreCredit,\n            },\n            options,\n        );\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    private async loadPaymentsWidget(\n        options: PaymentInitializeOptions & WithKlarnaV2PaymentInitializeOptions,\n    ): Promise<KlarnaLoadResponse> {\n        if (!options.klarnav2) {\n            throw new InvalidArgumentError(\n                'Unable to load widget because \"options.klarnav2\" argument is not provided.',\n            );\n        }\n\n        const {\n            methodId,\n            gatewayId,\n            klarnav2: { container, onLoad },\n        } = options;\n\n        if (!gatewayId) {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"payload.payment.gatewayId\" argument is not provided.',\n            );\n        }\n\n        const state = this.paymentIntegrationService.getState();\n        const cartId = state.getCartOrThrow().id;\n        const params = { params: cartId };\n\n        await this.klarnav2TokenUpdater.updateClientToken(gatewayId, { params }).catch(() => {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        });\n\n        return new Promise<KlarnaLoadResponse>((resolve) => {\n            const paymentMethod = state.getPaymentMethodOrThrow<KlarnaInitializationData>(methodId);\n            const { klarnaMultipleRadioButton } = paymentMethod.initializationData || {};\n\n            if (!this.klarnaPayments || !paymentMethod.clientToken) {\n                throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n            }\n\n            this.klarnaPayments.init({ client_token: paymentMethod.clientToken });\n            this.klarnaPayments.load(\n                {\n                    container,\n                    payment_method_category: this.isKlarnaMultipleRadioButtonEnabled(\n                        klarnaMultipleRadioButton,\n                        gatewayId,\n                        methodId,\n                    ),\n                },\n                (response) => {\n                    if (onLoad) {\n                        onLoad(response);\n                    }\n\n                    resolve(response);\n                },\n            );\n        });\n    }\n\n    private getUpdateSessionData(\n        methodId: string,\n        billingAddress: BillingAddress,\n        shippingAddress?: Address,\n    ): KlarnaUpdateSessionParams {\n        if (\n            !includes(\n                [...supportedCountries, ...supportedCountriesRequiringStates],\n                billingAddress.countryCode,\n            )\n        ) {\n            return {};\n        }\n\n        const data: KlarnaUpdateSessionParams = {\n            billing_address: this.mapToKlarnaAddress(\n                methodId,\n                billingAddress,\n                billingAddress.email,\n            ),\n        };\n\n        if (shippingAddress) {\n            data.shipping_address = this.mapToKlarnaAddress(\n                methodId,\n                shippingAddress,\n                billingAddress.email,\n            );\n        }\n\n        return data;\n    }\n\n    private needsStateCode(countryCode: string) {\n        return includes(supportedCountriesRequiringStates, countryCode);\n    }\n\n    private isKlarnaMultipleRadioButtonEnabled(\n        klarnaMultipleRadioButton: boolean | undefined,\n        gatewayId: string,\n        methodId: string,\n    ): string {\n        return klarnaMultipleRadioButton ? methodId : gatewayId;\n    }\n\n    private mapToKlarnaAddress(methodId: string, address: Address, email?: string): KlarnaAddress {\n        const state = this.paymentIntegrationService.getState();\n        const { checkoutSettings } = state.getStoreConfigOrThrow();\n        const paymentMethod = state.getPaymentMethodOrThrow<KlarnaInitializationData>(methodId);\n        const { enableBillie } = paymentMethod.initializationData || {};\n\n        const klarnaAddress: KlarnaAddress = {\n            street_address: address.address1,\n            city: address.city,\n            country: address.countryCode,\n            given_name: address.firstName,\n            family_name: address.lastName,\n            postal_code: address.postalCode,\n            region: this.needsStateCode(address.countryCode)\n                ? address.stateOrProvinceCode\n                : address.stateOrProvince,\n            email,\n        };\n\n        if (address.address2) {\n            klarnaAddress.street_address2 = address.address2;\n        }\n\n        if (address.phone) {\n            klarnaAddress.phone = address.phone;\n        }\n\n        if (\n            address.company &&\n            enableBillie &&\n            isExperimentEnabled(checkoutSettings.features, 'PI-3915.b2b_payment_session_for_klarna')\n        ) {\n            klarnaAddress.organization_name = address.company;\n        }\n\n        return klarnaAddress;\n    }\n\n    private async authorizeOrThrow(\n        paymentMethodategory: string,\n        methodId: string,\n    ): Promise<KlarnaAuthorizationResponse> {\n        await this.paymentIntegrationService.loadCheckout();\n\n        const state = this.paymentIntegrationService.getState();\n        const billingAddress = state.getBillingAddressOrThrow();\n        const shippingAddress = state.getShippingAddress();\n\n        const updateSessionData = this.getUpdateSessionData(\n            methodId,\n            billingAddress,\n            shippingAddress,\n        );\n\n        return new Promise<KlarnaAuthorizationResponse>((resolve, reject) => {\n            if (!this.klarnaPayments) {\n                return reject(\n                    new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized),\n                );\n            }\n\n            this.klarnaPayments.authorize(\n                {\n                    payment_method_category: paymentMethodategory,\n                },\n                updateSessionData,\n                (res) => {\n                    if (res.approved) {\n                        return resolve(res);\n                    }\n\n                    if (res.show_form) {\n                        return reject(new PaymentMethodCancelledError());\n                    }\n\n                    reject(new PaymentMethodInvalidError());\n                },\n            );\n        });\n    }\n}\n","export interface Features {\n    [featureName: string]: boolean | undefined;\n}\n\nexport default function isExperimentEnabled(\n    features: Features,\n    experimentName: string,\n    fallbackValue = true,\n): boolean {\n    return features[experimentName] ?? fallbackValue;\n}\n","import { ScriptLoader } from '@bigcommerce/script-loader';\n\nimport { PaymentMethodClientUnavailableError } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport KlarnaPayments from './klarna-payments';\nimport KlarnaV2Window from './klarnav2-window';\n\nconst SDK_URL = 'https://x.klarnacdn.net/kp/lib/v1/api.js';\n\nexport default class KlarnaV2ScriptLoader {\n    constructor(\n        private scriptLoader: ScriptLoader,\n        private klarnaWindow: KlarnaV2Window = window,\n    ) {}\n\n    async load(): Promise<KlarnaPayments> {\n        if (!this.klarnaWindow.Klarna?.Payments) {\n            await this.scriptLoader.loadScript(SDK_URL);\n        }\n\n        if (!this.klarnaWindow.Klarna?.Payments) {\n            throw new PaymentMethodClientUnavailableError();\n        }\n\n        return this.klarnaWindow.Klarna.Payments;\n    }\n}\n","export const INTERNAL_USE_ONLY =\n    'This API endpoint is for internal use only and may change in the future';\n","export const SDK_VERSION_HEADERS = { 'X-Checkout-SDK-Version': LIBRARY_VERSION };\n","import { RequestSender, Response } from '@bigcommerce/request-sender';\n\nimport {\n    ContentType,\n    INTERNAL_USE_ONLY,\n    PaymentMethod,\n    RequestOptions,\n    SDK_VERSION_HEADERS,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nexport default class KlarnaV2TokenUpdater {\n    constructor(private requestSender: RequestSender) {}\n\n    updateClientToken(\n        gatewayId: string,\n        { timeout, params }: RequestOptions = {},\n    ): Promise<Response<PaymentMethod>> {\n        const url = `/api/storefront/payments/${gatewayId}`;\n\n        return this.requestSender.get(url, {\n            timeout,\n            headers: {\n                Accept: ContentType.JsonV1,\n                'X-API-INTERNAL': INTERNAL_USE_ONLY,\n                ...SDK_VERSION_HEADERS,\n            },\n            params,\n        });\n    }\n\n    async klarnaOrderInitialization(\n        cartId: string,\n        clientToken: string | undefined,\n    ): Promise<void> {\n        const url = `/api/storefront/initialization/klarna`;\n        const options = {\n            headers: {\n                Accept: ContentType.JsonV1,\n                'X-API-INTERNAL': INTERNAL_USE_ONLY,\n                ...SDK_VERSION_HEADERS,\n            },\n            body: {\n                cartId,\n                clientToken,\n            },\n        };\n\n        await this.requestSender.put(url, options);\n    }\n}\n","import { createRequestSender } from '@bigcommerce/request-sender';\nimport { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport KlarnaV2PaymentStrategy from './klarnav2-payment-strategy';\nimport KlarnaV2ScriptLoader from './klarnav2-script-loader';\nimport KlarnaV2TokenUpdater from './klarnav2-token-updater';\n\nconst createKlarnaV2PaymentStrategy: PaymentStrategyFactory<KlarnaV2PaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    const { getHost } = paymentIntegrationService.getState();\n    const requestSender = createRequestSender({ host: getHost() });\n\n    return new KlarnaV2PaymentStrategy(\n        paymentIntegrationService,\n        new KlarnaV2ScriptLoader(getScriptLoader()),\n        new KlarnaV2TokenUpdater(requestSender),\n    );\n};\n\nexport default toResolvableModule(createKlarnaV2PaymentStrategy, [{ gateway: 'klarna' }]);\n","import { createKlarnaPaymentStrategy } from '@bigcommerce/checkout-sdk/integrations/klarna';\nimport { some } from 'lodash';\nimport React, { type FunctionComponent, useCallback } from 'react';\n\nimport { HostedWidgetPaymentComponent } from '@bigcommerce/checkout/hosted-widget-integration';\nimport {\n    isInstrumentCardCodeRequiredSelector,\n    isInstrumentCardNumberRequiredSelector,\n} from '@bigcommerce/checkout/instrument-utils';\nimport {\n    type PaymentMethodProps,\n    type PaymentMethodResolveId,\n    toResolvableComponent,\n} from '@bigcommerce/checkout/payment-integration-api';\n\nconst KlarnaPaymentMethod: FunctionComponent<PaymentMethodProps> = ({\n    checkoutService,\n    checkoutState,\n    method,\n    paymentForm,\n    ...rest\n}) => {\n    const initializeKlarnaPayment = useCallback(\n        (options: any) =>\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            checkoutService.initializePayment({\n                ...options,\n                integrations: [createKlarnaPaymentStrategy],\n                klarna: {\n                    container: `#${options.methodId}Widget`,\n                },\n            }),\n        [checkoutService],\n    );\n\n    const {\n        hidePaymentSubmitButton,\n        disableSubmit,\n        setFieldValue,\n        setSubmit,\n        setValidationSchema,\n    } = paymentForm;\n\n    const instruments = checkoutState.data.getInstruments(method) || [];\n\n    const {\n        data: { getCheckout, isPaymentDataRequired },\n        statuses: { isLoadingInstruments },\n    } = checkoutState;\n\n    const checkout = getCheckout();\n    const customer = checkoutState.data.getCustomer();\n    const isGuestCustomer = customer?.isGuest;\n    const isInstrumentFeatureAvailable =\n        !isGuestCustomer && Boolean(method.config.isVaultingEnabled);\n\n    return (\n        <HostedWidgetPaymentComponent\n            containerId={`${method.id}Widget`}\n            deinitializePayment={checkoutService.deinitializePayment}\n            disableSubmit={disableSubmit}\n            hidePaymentSubmitButton={hidePaymentSubmitButton}\n            initializePayment={initializeKlarnaPayment}\n            instruments={instruments}\n            isInstrumentCardCodeRequired={isInstrumentCardCodeRequiredSelector(checkoutState)}\n            isInstrumentCardNumberRequired={isInstrumentCardNumberRequiredSelector(checkoutState)}\n            isInstrumentFeatureAvailable={isInstrumentFeatureAvailable}\n            isLoadingInstruments={isLoadingInstruments()}\n            isPaymentDataRequired={isPaymentDataRequired()}\n            isSignedIn={some(checkout?.payments, { providerId: method.id })}\n            loadInstruments={checkoutService.loadInstruments}\n            method={method}\n            setFieldValue={setFieldValue}\n            setSubmit={setSubmit}\n            setValidationSchema={setValidationSchema}\n            signOut={checkoutService.signOutCustomer}\n            {...rest}\n        />\n    );\n};\n\nexport default toResolvableComponent<PaymentMethodProps, PaymentMethodResolveId>(\n    KlarnaPaymentMethod,\n    [{ id: 'klarna' }],\n);\n","import { createKlarnaV2PaymentStrategy } from '@bigcommerce/checkout-sdk/integrations/klarna';\nimport { some } from 'lodash';\nimport React, { type FunctionComponent, useCallback } from 'react';\n\nimport { HostedWidgetPaymentComponent } from '@bigcommerce/checkout/hosted-widget-integration';\nimport {\n    isInstrumentCardCodeRequiredSelector,\n    isInstrumentCardNumberRequiredSelector,\n} from '@bigcommerce/checkout/instrument-utils';\nimport {\n    type PaymentMethodProps,\n    type PaymentMethodResolveId,\n    toResolvableComponent,\n} from '@bigcommerce/checkout/payment-integration-api';\n\nconst KlarnaV2PaymentMethod: FunctionComponent<PaymentMethodProps> = ({\n    checkoutService,\n    checkoutState,\n    method,\n    paymentForm,\n    ...rest\n}) => {\n    const initializeKlarnaV2Payment = useCallback(\n        (options: any) =>\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            checkoutService.initializePayment({\n                ...options,\n                integrations: [createKlarnaV2PaymentStrategy],\n                klarnav2: {\n                    container: `#${options.methodId}Widget`,\n                },\n            }),\n        [checkoutService],\n    );\n\n    const {\n        hidePaymentSubmitButton,\n        disableSubmit,\n        setFieldValue,\n        setSubmit,\n        setValidationSchema,\n    } = paymentForm;\n\n    const instruments = checkoutState.data.getInstruments(method) || [];\n\n    const {\n        data: { getCheckout, isPaymentDataRequired },\n        statuses: { isLoadingInstruments },\n    } = checkoutState;\n\n    const checkout = getCheckout();\n    const customer = checkoutState.data.getCustomer();\n    const isGuestCustomer = customer?.isGuest;\n    const isInstrumentFeatureAvailable =\n        !isGuestCustomer && Boolean(method.config.isVaultingEnabled);\n\n    return (\n        <HostedWidgetPaymentComponent\n            containerId={`${method.id}Widget`}\n            deinitializePayment={checkoutService.deinitializePayment}\n            disableSubmit={disableSubmit}\n            hidePaymentSubmitButton={hidePaymentSubmitButton}\n            initializePayment={initializeKlarnaV2Payment}\n            instruments={instruments}\n            isInstrumentCardCodeRequired={isInstrumentCardCodeRequiredSelector(checkoutState)}\n            isInstrumentCardNumberRequired={isInstrumentCardNumberRequiredSelector(checkoutState)}\n            isInstrumentFeatureAvailable={isInstrumentFeatureAvailable}\n            isLoadingInstruments={isLoadingInstruments()}\n            isPaymentDataRequired={isPaymentDataRequired()}\n            isSignedIn={some(checkout?.payments, { providerId: method.id })}\n            loadInstruments={checkoutService.loadInstruments}\n            method={method}\n            setFieldValue={setFieldValue}\n            setSubmit={setSubmit}\n            setValidationSchema={setValidationSchema}\n            signOut={checkoutService.signOutCustomer}\n            {...rest}\n        />\n    );\n};\n\nexport default toResolvableComponent<PaymentMethodProps, PaymentMethodResolveId>(\n    KlarnaV2PaymentMethod,\n    [{ gateway: 'klarna' }],\n);\n"],"names":["EditButton","buttonId","shouldShowEditButton","translatedString","TranslatedString","id","className","onClick","preventDefault","type","PaymentDescriptor","shouldShowDescriptor","paymentDescriptor","PaymentWidget","additionalContainerClassName","containerId","hideContentWhenSignedOut","hideWidget","isSignInRequired","isSignedIn","method","renderCustomPaymentForm","shouldRenderCustomInstrument","shouldShowCreditCardFieldset","style","display","undefined","tabIndex","instruments","isInitializing","isAccountInstrument","isInstrumentFeatureAvailable","isInstrumentFeatureAvailableProp","isLoadingInstruments","shouldHideInstrumentExpiryDate","shouldShow","hideVerificationFields","storedCardValidationSchema","isPaymentDataRequired","setValidationSchema","loadInstruments","onUnhandledError","noop","deinitializeCustomer","deinitializePayment","setSubmit","initializeCustomer","initializePayment","signInCustomer","isInstrumentCardNumberRequired","validateInstrument","setFieldValue","isAddingNewCard","setIsAddingNewCard","useState","selectedInstrumentId","setSelectedInstrumentId","instrumentsRef","useRef","useEffect","current","getDefaultInstrumentId","useCallback","defaultInstrument","find","instrument","bigpayToken","getSelectedInstrument","currentSelectedId","getValidationSchema","currentSelectedInstrument","getSelectedBankAccountInstrument","addingNew","handleDeleteInstrument","length","nextId","handleUseNewCard","gatewayId","gateway","methodId","handleSelectInstrument","getValidateInstrument","shouldShowNumberField","initializeMethod","currentInstruments","selectedCardInstrument","currentSelectedInstrumentId","maybeInstrument","isCardInstrument","effectiveSelectedInstrumentId","selectedInstrument","i","cardInstruments","filter","accountInstruments","shouldShowInstrumentFieldset","isLoading","selectedAccountInstrument","shouldShowAccountInstrument","error","Error","isInitialRenderRef","instrumentsLength","isPaymentDataRequiredRef","selectedInstrumentIdRef","Number","LoadingOverlay","hideContentWhenLoading","AccountInstrumentFieldset","A","onSelectInstrument","onUseNewInstrument","CardInstrumentFieldset","onDeleteInstrument","shouldHideExpiryDate","StoreInstrumentFieldset","instrumentId","Boolean","PROVIDERS_WITHOUT_CARD_CODE","data","cart","getCart","lineItems","paymentMethod","config","isVaultingCvvEnabled","cardCode","initializationData","isVaultingCardCodeValidationAvailable","includes","provider","digitalItems","giftCertificates","trustedShippingAddress","isInstrumentCardCodeRequired","isVaultingCardNumberValidationAvailable","physicalItems","InstrumentMenuItem","testId","cardType","mapFromInstrumentCardType","brand","cardInfo","isExpired","expirationDate","month","expiryMonth","year","expiryYear","isValid","CreditCardIcon","cardTitle","niceType","endingIn","last4","expiryDate","InstrumentOption","handleClick","InstrumentUseNewButton","InstrumentMenu","map","key","InstrumentSelectButton","field","form","prevSelectedInstrumentIdRef","updateFieldValue","name","setTimeout","value","DropdownTrigger","dropdown","memo","renderInput","renderModal","props","ManageInstrumentsModal","Fieldset","additionalClassName","legend","Legend","hidden","ModalTrigger","modal","BasicFormField","render","MissingDataErrorType","NotInitializedErrorType","__webpack_require__","toResolvableModule","module","resolveIds","Object","assign","d","exports","definition","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","StandardError","constructor","message","super","setPrototypeOf","this","__proto__","captureStackTrace","stack","InvalidArgumentError","OrderFinalizationNotRequiredError","MissingBillingAddress","MissingCart","MissingCheckout","MissingConsignments","MissingCustomer","MissingCheckoutConfig","MissingOrder","MissingOrderConfig","MissingOrderId","MissingPayment","MissingPaymentId","MissingPaymentInstrument","MissingPaymentMethod","MissingPaymentRedirectUrl","MissingPaymentStatus","MissingPaymentToken","MissingShippingAddress","MissingDataError","subtype","CheckoutButtonNotInitialized","CustomerNotInitialized","PaymentNotInitialized","ShippingNotInitialized","SpamProtectionNotInitialized","NotInitializedError","PaymentMethodCancelledError","DEFAULT_RESPONSE","body","headers","status","RequestError","response","errors","PaymentMethodInvalidError","supportedCountries","supportedCountriesRequiringStates","KlarnaPaymentStrategy","paymentIntegrationService","klarnaScriptLoader","initialize","options","klarnaCredit","load","unsubscribe","subscribe","state","isPaymentMethodInitialized","loadWidget","checkout","getCheckout","outstandingBalance","coupons","deinitialize","Promise","resolve","execute","payload","payment","paymentData","paymentPayload","authorization_token","authorizationToken","authorize","submitOrder","useStoreCredit","finalize","reject","klarna","container","onLoad","loadPaymentMethod","getState","getPaymentMethod","clientToken","init","client_token","getUpdateSessionData","billingAddress","shippingAddress","countryCode","billing_address","mapToKlarnaAddress","email","shipping_address","needsStateCode","address","klarnaAddress","street_address","address1","city","country","given_name","firstName","family_name","lastName","postal_code","postalCode","region","stateOrProvinceCode","stateOrProvince","address2","street_address2","phone","getBillingAddress","getShippingAddress","updateSessionData","res","approved","show_form","PaymentMethodClientUnavailableError","KlarnaScriptLoader","scriptLoader","klarnaWindow","window","Klarna","Credit","loadScript","t","getScriptLoader","ContentType","KlarnaV2PaymentStrategy","klarnav2ScriptLoader","klarnav2TokenUpdater","klarnaPayments","loadPaymentsWidget","cartId","getCartOrThrow","getPaymentMethodOrThrow","klarnaMultipleRadioButton","klarnaOrderInitialization","isKlarnaMultipleRadioButtonEnabled","authorizeOrThrow","klarnav2","params","updateClientToken","catch","payment_method_category","checkoutSettings","getStoreConfigOrThrow","enableBillie","company","features","experimentName","fallbackValue","organization_name","loadCheckout","getBillingAddressOrThrow","KlarnaV2ScriptLoader","Payments","Json","JsonV1","INTERNAL_USE_ONLY","SDK_VERSION_HEADERS","KlarnaV2TokenUpdater","requestSender","timeout","url","Accept","put","getHost","createRequestSender","host","toResolvableComponent","checkoutService","checkoutState","paymentForm","rest","initializeKlarnaPayment","integrations","hidePaymentSubmitButton","disableSubmit","getInstruments","statuses","customer","getCustomer","isGuest","isVaultingEnabled","HostedWidgetPaymentComponent","isInstrumentCardCodeRequiredSelector","isInstrumentCardNumberRequiredSelector","some","payments","providerId","signOut","signOutCustomer","initializeKlarnaV2Payment"],"sourceRoot":""}